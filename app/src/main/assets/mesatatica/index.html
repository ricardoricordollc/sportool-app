<!DOCTYPE html>
<html>
<head>
    <title>Mesa Tática Compartilhada</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mesatatica.onrender.com/">
    <meta property="og:title" content="Mesa Tática Compartilhada"/>
    <meta property="og:description" content="SCOUT-TOOL -- FERRAMENTAESPORTIVA"/>
    <meta property="og:image" content="https://mesatatica.onrender.com/img/trofeujoia.png"/>
    <meta property="og:image:width" content="580"/>
    <meta property="og:image:height" content="464"/>
    <link rel="stylesheet" href="styles.css">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MSFDFBWDKZ"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZDWS2F3NE8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-ZDWS2F3NE8');
    </script>
    </head>
<body>
    <div id="background-square" class="background-square"></div>
    <div id="background-line"></div>
    <div id="background-line2"></div>
    <div id="background-line3"></div>
    <div id="background-line4"></div>
    <div id="background-line5"></div>
    <div id="background-line6"></div>
    <div id="background-line7"></div>
    <div id="background-line8"></div>
    <div id="background-line9"></div>
    <div id="background-line10"></div>
    <div id="background-line11"></div>
    <div id="background-line12"></div>
    <div id="background-line13"></div>
    <div id="background-line14"></div>
    <div id="background-line15"></div>
    <div id="background-line16"></div>
    <div id="background-line17"></div>
<div id="circle12" class="circlecentral" style="
    background: transparent;
    left: 237px;
    top: 100px;
    border: 2px solid #ffffff;
    color: #ffffff;
"></div>
    <div id="gol-square" class="gol-square"></div>
    <div id="gol2-square" class="gol2-square"></div>
    <div id="circle1" class="circle">1</div>
    <div id="circle2" class="circle">2</div>
    <div id="circle3" class="circle">3</div>
    <div id="circle4" class="circle">4</div>
    <div id="circle5" class="circle">5</div>
    <div id="circle6" class="circle">6</div>
    <div id="circle7" class="circle">7</div>
    <div id="circle8" class="circle">8</div>
    <div id="circle9" class="circle">9</div>
    <div id="circle10" class="circle">10</div>
    <div id="circle11" class="circle">11</div>
    <div id="circle13" class="circle" style="background: #ff3333;">11</div>
    <div id="circle14" class="circle" style="background: #ff3333;">2</div>
    <div id="circle15" class="circle" style="background: #ff3333;">3</div>
    <div id="circle16" class="circle" style="background: #ff3333;">4</div>
    <div id="circle17" class="circle" style="background: #ff3333;">5</div>
    <div id="circle18" class="circle" style="background: #ff3333;">6</div>
    <div id="circle19" class="circle" style="background: #ff3333;">7</div>
    <div id="circle20" class="circle" style="background: #ff3333;">8</div>
    <div id="circle21" class="circle" style="background: #ff3333;">9</div>
    <div id="circle22" class="circle" style="background: #ff3333;">10</div>
    <div id="circle23" class="circle">01</div>
    <div id="circle24" class="circle"></div>
    <div id="fullscreen-overlay" style="
        position: fixed; left:0; top:0; width:100vw; height:100vh; 
        background: rgba(0,0,0,0.7); color: #fff; 
        display: flex; align-items: center; justify-content: center; 
        z-index: 9999; font-size: 2em; cursor: pointer;">
        Toque para entrar na Mesa Tática
    </div>

<!-- Exit fullscreen button -->
    <button id="exit-fullscreen-btn" style="
        position: fixed;
        top: 330px; left: 20px;
        z-index: 10000;
        font-size: 1.2em;
        padding: 10px 18px;
        border-radius: 8px;
        background: #222; color: #fff;
        border: none;
        cursor: pointer;
        display: none;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    ">Sair (x)</button>
<button id="pen-path-btn" style="
    position: fixed;
    top: 330px; left: 302px;
    z-index: 10000;
    font-size: 1.2em;
    padding: 10px 18px;
    border-radius: 8px;
    background: #222; color: #fff;
    border: none;
    cursor: pointer;
    display: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
">✎ Desenho Tático</button>
<button id="ai-analise-btn" style="
    position: fixed;
    top: 330px; left: 120px;
    z-index: 10000;
    font-size: 1.2em;
    padding: 10px 18px;
    border-radius: 8px;
    background: #33aaff; color: #fff;
    border: none;
    cursor: pointer;
    display: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
">AI Análise</button>
<canvas id="trace-canvas" width="600" height="300" style="
    position:absolute;
    left:20px; top:20px;
    z-index: 10;
    pointer-events: none;
    border-radius:8px;
    background:transparent;
    display: block;
"></canvas>
<div id="ai-notification" style="
    display:none;
    position:fixed;
    bottom:40px; left:50%; transform:translateX(-50%);
    background:#33aaff;
    color:#fff; padding:18px 32px; border-radius:8px; z-index:10001;
    font-size:1.3em; box-shadow:0 2px 10px rgba(0,0,0,0.18);
"></div>
<script>
  // Enter Fullscreen
  document.getElementById('fullscreen-overlay').addEventListener('click', async function() {
      const el = document.documentElement;
      // Try fullscreen
      if (el.requestFullscreen) {
          await el.requestFullscreen();
      } else if (el.webkitRequestFullscreen) { /* Safari */
          await el.webkitRequestFullscreen();
      } else if (el.msRequestFullscreen) { /* IE11 */
          await el.msRequestFullscreen();
      }
      // Attempt to lock orientation to landscape
      if (screen.orientation && screen.orientation.lock) {
          try {
              await screen.orientation.lock('landscape');
          } catch (e) {
              // Some browsers might not support or allow it
          }
      }
      document.getElementById('fullscreen-overlay').style.display = 'none';
      // Ensure buttons update after entering fullscreen
      updateExitButton();
      updatePenPathButton();
      updateAIButton();
  });

  // Show/hide exit button on fullscreen change
  function updateExitButton() {
      const btn = document.getElementById('exit-fullscreen-btn');
      if (
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.msFullscreenElement
      ) {
          btn.style.display = 'block';
      } else {
          btn.style.display = 'none';
      }
  }

  document.addEventListener('fullscreenchange', updateExitButton);
  document.addEventListener('webkitfullscreenchange', updateExitButton);
  document.addEventListener('msfullscreenchange', updateExitButton);

  // Exit Fullscreen function
  document.getElementById('exit-fullscreen-btn').addEventListener('click', async function() {
      if (document.exitFullscreen) {
          await document.exitFullscreen();
      } else if (document.webkitExitFullscreen) { /* Safari */
          await document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) { /* IE11 */
          await document.msExitFullscreen();
      }
      // Optionally unlock orientation if supported
      if (screen.orientation && screen.orientation.unlock) {
          try {
              await screen.orientation.unlock();
          } catch (e) {}
      }
      // Ensure buttons update after exiting fullscreen
      updateExitButton();
      updatePenPathButton();
      updateAIButton();
  });
</script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const socket = io('https://mesatatica.onrender.com');

        // Store state for all circles
        const circles = {};
        const dragState = {};

        for (let i = 1; i <= 24; i++) {
            const el = document.getElementById('circle' + i);
            circles[i] = el;
            dragState[i] = {
                dragging: false,
                offsetX: 0,
                offsetY: 0,
                lastReceived: 0
            };

            // Mouse events
            el.addEventListener('mousedown', (e) => {
                dragState[i].dragging = true;
                dragState[i].offsetX = e.offsetX;
                dragState[i].offsetY = e.offsetY;
                dragState[i].active = true;
                dragState[i].touch = false;
                window.activeCircleId = i;
            });

            // Touch events
            el.addEventListener('touchstart', (e) => {
                dragState[i].dragging = true;
                const touch = e.touches[0];
                const rect = el.getBoundingClientRect();
                dragState[i].offsetX = touch.clientX - rect.left;
                dragState[i].offsetY = touch.clientY - rect.top;
                dragState[i].active = true;
                dragState[i].touch = true;
                window.activeCircleId = i;
                e.preventDefault();
            }, { passive: false });
        }

        // Mouse move
        document.addEventListener('mousemove', (e) => {
            for (let i = 1; i <= 24; i++) {
                if (dragState[i].dragging && !dragState[i].touch && window.activeCircleId === i) {
                    let x = e.clientX - dragState[i].offsetX;
                    let y = e.clientY - dragState[i].offsetY;
                    let ts = Date.now();
                    circles[i].style.left = x + 'px';
                    circles[i].style.top = y + 'px';
                    socket.emit('move_circle', { x, y, ts, id: i });
                }
            }
        });

        // Mouse up
        document.addEventListener('mouseup', () => {
            for (let i = 1; i <= 24; i++) {
                dragState[i].dragging = false;
                dragState[i].active = false;
            }
            window.activeCircleId = undefined;
        });

        // Touch move
        document.addEventListener('touchmove', (e) => {
            for (let i = 1; i <= 24; i++) {
                if (dragState[i].dragging && dragState[i].touch && window.activeCircleId === i) {
                    const touch = e.touches[0];
                    let x = touch.clientX - dragState[i].offsetX;
                    let y = touch.clientY - dragState[i].offsetY;
                    let ts = Date.now();
                    circles[i].style.left = x + 'px';
                    circles[i].style.top = y + 'px';
                    socket.emit('move_circle', { x, y, ts, id: i });
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Touch end
        document.addEventListener('touchend', () => {
            for (let i = 1; i <= 24; i++) {
                dragState[i].dragging = false;
                dragState[i].active = false;
            }
            window.activeCircleId = undefined;
        });

        // Listen for updates for all circles
        socket.on('update_circle', (data) => {
            const i = data.id;
            if (circles[i] && typeof data.ts === 'number' && data.ts >= dragState[i].lastReceived) {
                dragState[i].lastReceived = data.ts;
                circles[i].style.left = data.x + 'px';
                circles[i].style.top = data.y + 'px';
            }
        });

    </script>

<script>
    // Show/hide Pen Path button on fullscreen change
    function updatePenPathButton() {
        const btn = document.getElementById('pen-path-btn');
        if (
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement
        ) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }
    document.addEventListener('fullscreenchange', updatePenPathButton);
    document.addEventListener('webkitfullscreenchange', updatePenPathButton);
    document.addEventListener('msfullscreenchange', updatePenPathButton);

    // Pen Path Drawing Logic
    let penMode = false;
    const penBtn = document.getElementById('pen-path-btn');
    const canvas = document.getElementById('trace-canvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    let currentPath = [];

    penBtn.addEventListener('click', function() {
        penMode = !penMode;
        penBtn.style.background = penMode ? "#33aaff" : "#222";
        canvas.style.pointerEvents = penMode ? "auto" : "none";
        penBtn.textContent = penMode ? "✎ Desenhando..." : "✎ Desenho Tático";
    });

    // Only allow drawing inside the field
    function getFieldOffset(e) {
        const rect = canvas.getBoundingClientRect();
        let x, y;
        if (e.touches) {
            x = e.touches[0].clientX - rect.left;
            y = e.touches[0].clientY - rect.top;
        } else {
            x = e.clientX - rect.left;
            y = e.clientY - rect.top;
        }
        return {x, y};
    }

    canvas.addEventListener('mousedown', function(e) {
        if (!penMode) return;
        drawing = true;
        currentPath = [];
        const {x, y} = getFieldOffset(e);
        ctx.beginPath();
        ctx.moveTo(x, y);
        currentPath.push([x, y]);
    });
    canvas.addEventListener('mousemove', function(e) {
        if (drawing && penMode) {
            const {x, y} = getFieldOffset(e);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "#ff3333";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.stroke();
            currentPath.push([x, y]);
        }
    });
    canvas.addEventListener('mouseup', function(e) {
        if (drawing && penMode) {
            drawing = false;
            ctx.closePath();
            // Share path via socket.io
            socket.emit('path_draw', { path: currentPath });
        }
    });
    canvas.addEventListener('mouseleave', function(e) {
        if (drawing && penMode) {
            drawing = false;
            ctx.closePath();
            socket.emit('path_draw', { path: currentPath });
        }
    });

    // Touch support
    canvas.addEventListener('touchstart', function(e) {
        if (!penMode) return;
        drawing = true;
        currentPath = [];
        const {x, y} = getFieldOffset(e);
        ctx.beginPath();
        ctx.moveTo(x, y);
        currentPath.push([x, y]);
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchmove', function(e) {
        if (drawing && penMode) {
            const {x, y} = getFieldOffset(e);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "#ff3333";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.stroke();
            currentPath.push([x, y]);
        }
        e.preventDefault();
    }, { passive: false });
    canvas.addEventListener('touchend', function(e) {
        if (drawing && penMode) {
            drawing = false;
            ctx.closePath();
            socket.emit('path_draw', { path: currentPath });
        }
        e.preventDefault();
    }, { passive: false });

    // Receive and render shared paths from other users
    socket.on('path_draw', function(data) {
        if (data && Array.isArray(data.path)) {
            ctx.beginPath();
            for (let i = 0; i < data.path.length; i++) {
                const [x, y] = data.path[i];
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = "#ff3333";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.stroke();
            ctx.closePath();
        }
    });

    // Optional: Clear canvas on reload/fullscreen
    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', clearCanvas);
    document.addEventListener('fullscreenchange', clearCanvas);
</script>
<script>
    // Show AI button on fullscreen
    function updateAIButton() {
        const btn = document.getElementById('ai-analise-btn');
        if (
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.msFullscreenElement
        ) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }
    document.addEventListener('fullscreenchange', updateAIButton);
    document.addEventListener('webkitfullscreenchange', updateAIButton);
    document.addEventListener('msfullscreenchange', updateAIButton);

    // Helper: Get green team positions (circle2 to circle11)
    function getGreenTeamPositions() {
        const positions = [];
        for (let i = 2; i <= 11; i++) {
            const el = document.getElementById('circle' + i);
            const left = parseInt(el.style.left || el.offsetLeft);
            const top = parseInt(el.style.top || el.offsetTop);
            positions.push({ id: i, left, top });
        }
        return positions;
    }

    // Helper: Update red team positions (circle13 to circle23)
    function setRedTeamPositions(arr) {
        for (const p of arr) {
            const el = document.getElementById('circle' + p.id);
            if (el) {
                el.style.left = p.left + 'px';
                el.style.top = p.top + 'px';
            }
        }
    }

    function getBallPosition() {
        const el = document.getElementById('circle24');
        const left = parseInt(el.style.left || el.offsetLeft);
        const top = parseInt(el.style.top || el.offsetTop);
        return { left, top };
    }

    // Custom notification (instead of alert)
    function showAINotification(message) {
        const notif = document.getElementById('ai-notification');
        notif.textContent = message;
        notif.style.display = 'block';
        setTimeout(() => { notif.style.display = 'none'; }, 2200);
    }

    document.getElementById('ai-analise-btn').addEventListener('click', async function() {
        const greenPositions = getGreenTeamPositions();
        const ballPosition = getBallPosition();
        // Show loading
        this.textContent = "Analisando...";
        this.disabled = true;
        try {
            const response = await fetch('/ai/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ green: greenPositions, ball: ballPosition })
            });
            const result = await response.json();
            if (result.red && Array.isArray(result.red)) {
                setRedTeamPositions(result.red);
                showAINotification("AI posicionou o time vermelho!");
            } else {
                showAINotification("Erro na resposta da AI.");
            }
        } catch (e) {
            showAINotification("Falha na análise AI.");
        }
        this.textContent = "AI Análise";
        this.disabled = false;

        // Ensure buttons are correct (optional, for robustness)
        updateAIButton();
        if (typeof updatePenPathButton === 'function') updatePenPathButton();
        if (typeof updateExitButton === 'function') updateExitButton();
    });
</script>
<img src="img/Guarani.png" alt="Guarani F.C." style="
    position: fixed;
    right: 0;
    bottom: 0;
    width: 200px;    /* Adjust size as needed */
    height: auto;
    z-index: 9000;   /* Below overlays but above field */
    opacity: 0.85;   /* Optional: subtle transparency */
    pointer-events: none; /* Prevents blocking clicks */
">
</body>
</html>
